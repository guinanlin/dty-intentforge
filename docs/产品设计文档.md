# 意图识别服务 - 产品设计文档

## 文档信息

- **产品名称**：意图识别服务（Intent Recognition Service）
- **核心功能**：基于 Rasa NLU 的自然语言意图识别
- **技术栈**：FastAPI + Rasa NLU
- **版本**：v1.0

---

## 0. 核心逻辑说明

### 0.1 功能定位

本项目提供**一个 FastAPI 接口**，用于识别用户输入的自然语言文本的意图。

### 0.2 意图分类体系

**核心原则**：无论用户输入什么内容，接口都必须返回一个意图。

意图分为两大类：

1. **明确意图（Defined Intents）**
   - 通过模型训练数据定义的、有明确业务含义的意图
   - 例如：`query_order`（查询订单）、`check_inventory`（查询库存）、`greet`（问候）等
   - **触发条件**：模型识别到匹配的明确意图，且置信度 ≥ 0.3

2. **通用意图（Fallback Intent）**
   - 当模型无法匹配到任何明确意图时返回的通用/未识别意图
   - 固定名称：`nlu_fallback`
   - **触发条件**：所有明确意图的置信度都 < 0.3

### 0.3 处理流程

```
用户输入任何文本
    ↓
FastAPI 接口接收
    ↓
Rasa 模型推理
    ↓
判断：最高置信度是否 ≥ 0.3？
    ├─ 是 → 返回明确意图（如 query_order）
    └─ 否 → 返回通用意图（nlu_fallback）
    ↓
返回 JSON 响应（始终包含一个意图）
```

### 0.4 关键保证

- ✅ **所有输入都有意图输出**：不存在"无意图"或"空意图"的情况
- ✅ **明确意图优先**：如果能识别到明确意图，优先返回明确意图
- ✅ **通用意图兜底**：如果无法识别明确意图，返回 `nlu_fallback` 作为兜底

---

## 1. 功能需求

### 1.1 核心功能定义

**功能名称**：意图识别（Intent Recognition）

**功能描述**：接收用户输入的自然语言文本，识别用户的意图（Intent）和提取关键实体（Entity），返回结构化的识别结果。

**核心逻辑**：
- **输入**：用户输入的任何自然语言文本
- **输出**：始终返回一个意图（Intent），无论输入什么内容
- **意图分类**：意图分为两大类
  1. **明确意图**：通过模型训练定义的、有明确业务含义的意图（如查询订单、查询库存等）
  2. **通用意图**：当模型无法匹配到任何明确意图时，返回的通用/未识别意图（fallback）

**输出内容**：意图名称、置信度、实体列表、意图排名

### 1.2 功能需求细化

#### 1.2.1 输入要求

- **输入格式**：JSON 格式，包含 `text` 字段
- **文本长度**：支持 1-500 字符
- **语言支持**：中文（简体）
- **文本内容**：用户自然语言表达，支持口语化、简写等

**示例输入**：
```json
{
  "text": "帮我查一下订单12345的状态"
}
```

#### 1.2.2 输出要求

- **输出格式**：JSON 格式
- **必须字段**：
  - `text`：原始输入文本
  - `intent`：识别的意图（包含 `name` 和 `confidence`）
  - `entities`：提取的实体列表（可选）
  - `intent_ranking`：意图排名列表（Top 5）

**示例输出**：

**情况A：识别到明确意图**
```json
{
  "text": "帮我查一下订单12345的状态",
  "intent": {
    "name": "query_order",
    "confidence": 0.98
  },
  "entities": [
    {
      "entity": "order_id",
      "value": "12345",
      "start": 7,
      "end": 12,
      "confidence": 0.95
    }
  ],
  "intent_ranking": [
    {"name": "query_order", "confidence": 0.98},
    {"name": "check_inventory", "confidence": 0.01},
    {"name": "greet", "confidence": 0.01}
  ]
}
```

**情况B：未识别到明确意图（返回通用意图）**
```json
{
  "text": "今天天气不错",
  "intent": {
    "name": "nlu_fallback",
    "confidence": 0.20
  },
  "entities": [],
  "intent_ranking": [
    {"name": "greet", "confidence": 0.20},
    {"name": "query_order", "confidence": 0.15},
    {"name": "check_inventory", "confidence": 0.10}
  ]
}
```

#### 1.2.3 支持的意图类型

**意图分类体系**：

意图分为两大类：

**1. 明确意图（Defined Intents）**

通过训练数据定义的、有明确业务含义的意图。当用户输入匹配到这些意图时，返回对应的意图名称。

| 意图名称 | 描述 | 示例 |
|---------|------|------|
| `greet` | 问候 | "你好"、"早上好"、"在吗" |
| `query_order` | 查询订单 | "查看我的订单状态"、"订单12345在哪里了" |
| `check_inventory` | 查询库存 | "产品A的库存有多少"、"iPhone还有货吗" |
| `create_return` | 退货申请 | "我要退货"、"申请退款" |

**2. 通用意图（Fallback Intent）**

当模型无法匹配到任何明确意图时（置信度低于阈值），返回的通用/未识别意图。这表示用户输入的内容不在已定义的意图范围内。

| 意图名称 | 描述 | 触发条件 | 示例输入 |
|---------|------|----------|----------|
| `nlu_fallback` | 未识别/通用意图 | 所有明确意图的置信度都 < 0.3 | "随便说点什么"、"今天天气不错"、"帮我做点别的" |

**关键原则**：
- **无论用户输入什么，接口都必须返回一个意图**
- 如果能匹配到明确意图，返回明确意图（置信度 > 0.3）
- 如果无法匹配到明确意图，返回 `nlu_fallback`（置信度 < 0.3）
- 不存在"无意图"的情况，所有输入都有对应的意图输出

#### 1.2.4 支持的实体类型

| 实体名称 | 描述 | 示例 |
|---------|------|------|
| `order_id` | 订单号 | "12345"、"ORD-2024-001" |
| `product_name` | 产品名称 | "iPhone"、"产品A" |
| `product_code` | 产品编码 | "SKU123"、"P-001" |

#### 1.2.5 性能要求

- **响应时间**：单次请求处理时间 < 200ms（P95）
- **准确率**：意图识别准确率 > 85%
- **置信度阈值**：低于 0.3 时返回 `nlu_fallback` 意图

### 1.3 错误处理需求

- **空文本**：返回 400 错误，提示"输入文本不能为空"
- **模型未加载**：返回 500 错误，提示"模型未加载"
- **识别失败**：返回置信度 < 0.3 的结果，意图为 `nlu_fallback`

### 1.4 Rasa NLU 识别能力说明

#### 1.4.1 识别能力边界

Rasa NLU 是基于训练数据的模式匹配和统计学习模型，其识别能力有以下特点：

**能够识别的情况**：
- ✅ 训练数据中定义的明确意图
- ✅ 包含明确动作关键词的短文本（如"查询订单"、"查看库存"）
- ✅ 与训练示例相似度高的表达方式
- ✅ 训练数据中覆盖的实体信息

**难以识别的情况**：
- ❌ **隐含意图**：需要推理才能理解的深层语义（如从描述性文本中推断业务意图）
- ❌ **过长描述性文本**：超过 100 字符的叙述性内容，缺少明确动作关键词
- ❌ **训练数据未覆盖的表达**：完全不在训练数据范围内的新表达方式
- ❌ **复杂上下文推理**：需要结合多句话或背景知识才能理解的意图

#### 1.4.2 实际场景示例

**示例1：描述性文本（难以识别）**

**输入文本**：
```
"我今天早上去见了一个客户，然后今天这个客户是我第一次跟他见面。然后我们交流很开心，然后他跟我喝了咖啡，然后干什么什么什么事情。然后这里头他其实是没有意思就是通过这个描述呢，逻辑上我们应该理解出他是说我去新建一个客户"
```

**可能的输出结果**（如果训练数据中没有"新建客户"意图）：
```json
{
  "text": "我今天早上去见了一个客户，然后今天这个客户是我第一次跟他见面。然后我们交流很开心，然后他跟我喝了咖啡，然后干什么什么什么事情。然后这里头他其实是没有意思就是通过这个描述呢，逻辑上我们应该理解出他是说我去新建一个客户",
  "intent": {
    "name": "nlu_fallback",
    "confidence": 0.25
  },
  "entities": [],
  "intent_ranking": [
    {"name": "greet", "confidence": 0.25},
    {"name": "query_order", "confidence": 0.15},
    {"name": "check_inventory", "confidence": 0.10},
    {"name": "create_return", "confidence": 0.05}
  ]
}
```

**分析**：
- 文本过长（100+ 字符），描述性强
- 缺少明确的动作关键词（如"新建"、"创建"）
- 隐含意图需要推理，Rasa NLU 难以直接理解
- 所有明确意图置信度 < 0.3，返回 `nlu_fallback`

**示例2：简洁明确文本（容易识别）**

**输入文本**：
```
"我今天见了一个新客户，需要新建客户档案"
```

**可能的输出结果**（如果训练数据中有 `create_customer` 意图）：
```json
{
  "text": "我今天见了一个新客户，需要新建客户档案",
  "intent": {
    "name": "create_customer",
    "confidence": 0.85
  },
  "entities": [
    {
      "entity": "customer_name",
      "value": "客户",
      "start": 6,
      "end": 8,
      "confidence": 0.75
    }
  ],
  "intent_ranking": [
    {"name": "create_customer", "confidence": 0.85},
    {"name": "greet", "confidence": 0.10},
    {"name": "query_order", "confidence": 0.05}
  ]
}
```

**分析**：
- 文本简洁，包含明确关键词"新建客户"
- 与训练数据中的示例相似度高
- 置信度高（0.85），识别准确

**示例3：有训练数据但文本描述性强（可能识别）**

**输入文本**：
```
"今天早上见了一个客户，第一次见面，交流很愉快，需要录入系统"
```

**可能的输出结果**（如果训练数据中有 `create_customer` 意图，且包含类似示例）：
```json
{
  "text": "今天早上见了一个客户，第一次见面，交流很愉快，需要录入系统",
  "intent": {
    "name": "create_customer",
    "confidence": 0.45
  },
  "entities": [
    {
      "entity": "customer_name",
      "value": "客户",
      "start": 6,
      "end": 8,
      "confidence": 0.60
    }
  ],
  "intent_ranking": [
    {"name": "create_customer", "confidence": 0.45},
    {"name": "greet", "confidence": 0.20},
    {"name": "query_order", "confidence": 0.15}
  ]
}
```

**分析**：
- 包含"第一次见面"、"录入系统"等关键词
- 如果训练数据中有类似示例，可能识别为 `create_customer`
- 置信度中等（0.45），因为文本较长且描述性强

#### 1.4.3 改进建议

**1. 优化训练数据**

针对需要识别的意图，在训练数据中添加多种表达方式：

```yaml
- intent: create_customer
  examples: |
    - 新建一个客户
    - 添加客户信息
    - 今天见了一个新客户，需要录入
    - 第一次见面的客户要创建档案
    - 见了一个客户，需要新建
    - 新客户需要录入系统
    - 客户第一次见面，要建立档案
```

**2. 引导用户输入**

- **推荐**：使用简洁、包含明确关键词的表达
  - ✅ "新建客户"
  - ✅ "今天见了一个新客户，需要录入"
  - ✅ "添加客户信息"
  
- **不推荐**：过长的描述性文本
  - ❌ "我今天早上去见了一个客户，然后今天这个客户是我第一次跟他见面..."（描述性）

**3. 后处理优化**（可选）

如果必须支持描述性文本，可以考虑：
- 增加更多训练示例，覆盖更多表达方式
- 使用更复杂的模型（如 Transformer-based 模型）
- 结合规则引擎做后处理，识别特定模式

#### 1.4.4 识别能力总结

| 文本类型 | 长度 | 关键词 | 训练数据覆盖 | 识别成功率 | 典型置信度 |
|---------|------|--------|------------|----------|----------|
| 简洁明确 | 短（< 30字） | 明确 | 有 | 高（> 90%） | 0.8-0.95 |
| 描述性但有关键词 | 中（30-80字） | 有 | 有 | 中（50-70%） | 0.4-0.6 |
| 纯描述性 | 长（> 80字） | 无 | 无 | 低（< 30%） | 0.2-0.3 |
| 隐含意图 | 任意 | 无 | 无 | 极低（< 10%） | < 0.3 |

**关键结论**：
- Rasa NLU 适合识别**明确的、有明确动作关键词的意图**
- 对于**隐含意图和描述性文本**，识别能力有限，通常会返回 `nlu_fallback`
- 通过**优化训练数据**和**引导用户输入**，可以显著提升识别准确率

---

## 2. 技术实现逻辑

### 2.1 整体架构

```
用户请求（HTTP POST）
    ↓
FastAPI 路由层（app/api/nlu_router.py）
    ↓
数据验证（Pydantic Schema）
    ↓
Rasa 模型加载器（app/core/rasa_loader.py）
    ↓
Rasa NLU 模型推理（Interpreter.parse()）
    ↓
结果格式化（转换为响应模型）
    ↓
返回 JSON 响应
```

### 2.2 数据流转详解

#### 2.2.1 请求接收与验证

**位置**：`app/api/nlu_router.py`

**流程**：
1. FastAPI 接收 POST 请求到 `/nlu/predict`
2. 使用 Pydantic 模型 `TextInput` 验证请求体
3. 检查 `text` 字段是否为空
4. 如果为空，返回 400 错误

**代码逻辑**：
```python
@router.post("/predict", response_model=NLUResponse)
async def predict_intent(input: TextInput):
    # 1. 验证输入
    if not input.text.strip():
        raise HTTPException(status_code=400, detail="输入文本不能为空")
    
    # 2. 获取模型解释器（单例）
    interpreter = RasaNLULoader.get_interpreter()
    
    # 3. 调用模型进行推理
    result = interpreter.parse(input.text)
    
    # 4. 格式化并返回结果
    return NLUResponse(...)
```

#### 2.2.2 模型加载逻辑

**位置**：`app/core/rasa_loader.py`

**设计模式**：单例模式（确保模型只加载一次）

**流程**：
1. 首次调用时检查模型文件是否存在
2. 如果不存在，抛出 `FileNotFoundError`
3. 如果存在，使用 `Interpreter.load()` 加载模型
4. 将加载的模型保存在类变量 `_interpreter` 中
5. 后续调用直接返回已加载的模型

**代码逻辑**：
```python
class RasaNLULoader:
    _interpreter = None  # 类变量，保存模型实例
    
    @classmethod
    def get_interpreter(cls):
        # 1. 检查模型是否已加载
        if cls._interpreter is None:
            # 2. 检查模型文件是否存在
            if not os.path.exists(settings.MODEL_PATH):
                raise FileNotFoundError(f"模型文件不存在: {settings.MODEL_PATH}")
            
            # 3. 加载模型（首次加载，耗时操作）
            cls._interpreter = Interpreter.load(settings.MODEL_PATH)
        
        # 4. 返回模型实例
        return cls._interpreter
```

**关键点**：
- 使用单例模式避免重复加载模型（模型加载耗时）
- 模型文件路径从配置中读取：`models/latest_nlu.tar.gz`
- 模型加载是阻塞操作，但只在首次调用时执行

#### 2.2.3 意图识别推理

**位置**：Rasa NLU 模型内部

**核心逻辑**：无论输入什么，模型都会返回一个意图（要么是明确意图，要么是通用意图）

**处理流程**：
1. **文本预处理**：使用 `WhitespaceTokenizer` 分词
2. **特征提取**：
   - `RegexFeaturizer`：正则特征
   - `LexicalSyntacticFeaturizer`：词法句法特征
   - `CountVectorsFeaturizer`：词向量特征（字符级和词级）
3. **意图分类**：使用 `DIETClassifier` 进行意图分类，计算所有明确意图的置信度
4. **实体提取**：从文本中提取实体（如订单号、产品名）
5. **意图判定**：
   - **情况A：找到明确意图**（最高置信度 ≥ 0.3）
     - 返回置信度最高的明确意图（如 `query_order`、`check_inventory` 等）
   - **情况B：未找到明确意图**（所有明确意图的置信度 < 0.3）
     - `FallbackClassifier` 触发，返回通用意图 `nlu_fallback`

**场景一：识别到明确意图**

```
输入文本："帮我查一下订单12345的状态"
    ↓
Tokenizer: ["帮我", "查", "一下", "订单", "12345", "的", "状态"]
    ↓
Featurizer: 提取特征向量
    ↓
DIETClassifier: 
  - 计算各意图置信度：
    * query_order: 0.98
    * check_inventory: 0.01
    * greet: 0.01
  - 实体提取：order_id="12345"
    ↓
FallbackClassifier: 检查最高置信度 (0.98 > 0.3，通过)
    ↓
输出结果（明确意图）：
{
  "intent": {"name": "query_order", "confidence": 0.98},
  "entities": [{"entity": "order_id", "value": "12345", ...}],
  "intent_ranking": [
    {"name": "query_order", "confidence": 0.98},
    {"name": "check_inventory", "confidence": 0.01},
    ...
  ]
}
```

**场景二：未识别到明确意图（返回通用意图）**

```
输入文本："今天天气不错"
    ↓
Tokenizer: ["今天", "天气", "不错"]
    ↓
Featurizer: 提取特征向量
    ↓
DIETClassifier: 
  - 计算各意图置信度：
    * query_order: 0.15
    * check_inventory: 0.10
    * greet: 0.20
    * create_return: 0.05
  - 所有明确意图置信度 < 0.3
    ↓
FallbackClassifier: 触发（最高置信度 0.20 < 0.3）
    ↓
输出结果（通用意图）：
{
  "intent": {"name": "nlu_fallback", "confidence": 0.20},
  "entities": [],
  "intent_ranking": [
    {"name": "greet", "confidence": 0.20},
    {"name": "query_order", "confidence": 0.15},
    ...
  ]
}
```

**关键点**：
- **所有输入都有意图输出**：不存在"无意图"的情况
- **明确意图优先**：如果最高置信度 ≥ 0.3，返回明确意图
- **通用意图兜底**：如果所有明确意图置信度 < 0.3，返回 `nlu_fallback`
- **置信度阈值**：0.3 是区分明确意图和通用意图的分界线

#### 2.2.4 结果格式化

**位置**：`app/api/nlu_router.py`

**流程**：
1. 从 Rasa 模型返回的 `result` 字典中提取数据
2. 构造 `NLUResponse` 对象
3. 限制 `intent_ranking` 为 Top 5
4. 返回 Pydantic 模型（自动序列化为 JSON）

**代码逻辑**：
```python
result = interpreter.parse(input.text)

return NLUResponse(
    text=input.text,  # 原始文本
    intent=result["intent"],  # 意图结果
    entities=result.get("entities", []),  # 实体列表
    intent_ranking=result.get("intent_ranking", [])[:5]  # Top 5 意图排名
)
```

**数据映射**：
- Rasa 返回的 `result["intent"]` 是字典：`{"name": "query_order", "confidence": 0.98}`
- 直接映射到 `IntentResult` 模型
- `entities` 列表直接映射到 `EntityResult` 列表

---

## 3. 数据模型设计

### 3.1 请求模型

**文件**：`app/schemas/nlu_schema.py`

**模型定义**：
```python
class TextInput(BaseModel):
    text: str
```

**验证规则**：
- `text` 必须为字符串类型
- 不能为空（在路由层进行额外检查）

### 3.2 响应模型

**文件**：`app/schemas/nlu_schema.py`

**模型定义**：
```python
class IntentResult(BaseModel):
    name: str          # 意图名称，如 "query_order"
    confidence: float  # 置信度，0.0-1.0

class EntityResult(BaseModel):
    entity: str        # 实体类型，如 "order_id"
    value: str         # 实体值，如 "12345"
    start: int         # 实体在文本中的起始位置
    end: int           # 实体在文本中的结束位置
    confidence: float # 实体识别置信度

class NLUResponse(BaseModel):
    text: str                    # 原始输入文本
    intent: IntentResult         # 识别的意图
    entities: List[EntityResult] # 实体列表（可为空）
    intent_ranking: List[Dict]   # 意图排名列表（Top 5）
```

**数据示例**：
```json
{
  "text": "帮我查一下订单12345的状态",
  "intent": {
    "name": "query_order",
    "confidence": 0.98
  },
  "entities": [
    {
      "entity": "order_id",
      "value": "12345",
      "start": 7,
      "end": 12,
      "confidence": 0.95
    }
  ],
  "intent_ranking": [
    {"name": "query_order", "confidence": 0.98},
    {"name": "check_inventory", "confidence": 0.01},
    {"name": "greet", "confidence": 0.01}
  ]
}
```

---

## 4. API 接口设计

### 4.1 意图识别接口

**接口路径**：`POST /nlu/predict`

**请求头**：
```
Content-Type: application/json
```

**请求体**：
```json
{
  "text": "帮我查一下订单12345的状态"
}
```

**响应状态码**：
- `200`：成功
- `400`：请求参数错误（文本为空）
- `500`：服务器错误（模型未加载等）

**响应体**：

**情况A：识别到明确意图**
```json
{
  "text": "帮我查一下订单12345的状态",
  "intent": {
    "name": "query_order",
    "confidence": 0.98
  },
  "entities": [
    {
      "entity": "order_id",
      "value": "12345",
      "start": 7,
      "end": 12,
      "confidence": 0.95
    }
  ],
  "intent_ranking": [
    {"name": "query_order", "confidence": 0.98},
    {"name": "check_inventory", "confidence": 0.01},
    {"name": "greet", "confidence": 0.01}
  ]
}
```

**情况B：未识别到明确意图（返回通用意图）**
```json
{
  "text": "随便说点什么",
  "intent": {
    "name": "nlu_fallback",
    "confidence": 0.25
  },
  "entities": [],
  "intent_ranking": [
    {"name": "greet", "confidence": 0.25},
    {"name": "query_order", "confidence": 0.15},
    {"name": "check_inventory", "confidence": 0.10}
  ]
}
```

**关键说明**：
- **接口保证**：无论输入什么内容，接口都会返回一个意图
- **明确意图**：当识别到明确意图时（置信度 ≥ 0.3），返回对应的意图名称
- **通用意图**：当无法识别到明确意图时（所有明确意图置信度 < 0.3），返回 `nlu_fallback`
- **不存在空意图**：所有输入都有对应的意图输出

### 4.2 健康检查接口

**接口路径**：`GET /`

**响应体**：
```json
{
  "message": "ERP Rasa NLU Service is running!"
}
```

---

## 5. 模型训练流程

### 5.1 训练数据准备

**文件位置**：`rasa_data/nlu.yml`

**数据格式**：YAML 格式，定义意图和训练示例

**数据结构**：
```yaml
version: "3.1"
nlu:
- intent: greet
  examples: |
    - 你好
    - 早上好
    - 在吗

- intent: query_order
  examples: |
    - 查看我的订单状态
    - 订单12345在哪里了
    - 帮我查一下物流信息
    - 我的包裹发了吗
    - 订单什么时候到达
```

**关键点**：
- 每个意图需要至少 10-20 个训练示例
- 示例应该覆盖不同的表达方式（正式、口语化、简写等）
- 实体标注在示例中通过特殊语法标注（如 `[订单号](order_id)12345`）

### 5.2 模型配置

**文件位置**：`rasa_data/config.yml`

**配置内容**：
```yaml
language: zh

pipeline:
  - name: WhitespaceTokenizer      # 中文分词器
  - name: RegexFeaturizer          # 正则特征提取
  - name: LexicalSyntacticFeaturizer # 词法句法特征
  - name: CountVectorsFeaturizer   # 词级向量特征
  - name: CountVectorsFeaturizer   # 字符级向量特征
    analyzer: char_wb
    min_ngram: 1
    max_ngram: 4
  - name: DIETClassifier            # 意图分类和实体提取
    epochs: 100
  - name: FallbackClassifier       # 降级处理
    threshold: 0.3
```

**Pipeline 说明**：
1. **WhitespaceTokenizer**：按空格分词（中文需要）
2. **RegexFeaturizer**：提取正则匹配特征
3. **LexicalSyntacticFeaturizer**：提取词法和句法特征
4. **CountVectorsFeaturizer**（词级）：提取词级别的 n-gram 特征
5. **CountVectorsFeaturizer**（字符级）：提取字符级别的 n-gram 特征（1-4 字符）
6. **DIETClassifier**：深度学习分类器，同时进行意图分类和实体提取
7. **FallbackClassifier**：当置信度 < 0.3 时，返回 `nlu_fallback` 意图

### 5.3 模型训练

**脚本位置**：`scripts/train_rasa_nlu.py`

**训练流程**：
1. 读取 `rasa_data/nlu.yml` 训练数据
2. 读取 `rasa_data/config.yml` 配置
3. 调用 Rasa 训练命令
4. 将训练好的模型保存到 `models/latest_nlu.tar.gz`

**训练命令**（脚本内部）：
```python
from rasa.nlu.training_data import load_data
from rasa.nlu import config
from rasa.nlu.model import Trainer

# 加载训练数据
training_data = load_data("rasa_data/nlu.yml")

# 加载配置
nlu_config = config.load("rasa_data/config.yml")

# 创建训练器
trainer = Trainer(nlu_config)

# 训练模型
interpreter = trainer.train(training_data)

# 保存模型
model_path = trainer.persist("models/", fixed_model_name="latest_nlu")
```

**训练输出**：
- 模型文件：`models/latest_nlu.tar.gz`
- 训练日志：显示训练进度、损失值等

**训练时间**：通常 30 秒 ~ 5 分钟（取决于数据量和机器性能）

### 5.4 模型更新流程

**场景**：需要添加新意图或优化现有意图

**步骤**：
1. 修改 `rasa_data/nlu.yml`，添加新意图或补充训练示例
2. 运行训练脚本：`python scripts/train_rasa_nlu.py`
3. 训练完成后，新模型保存为 `models/latest_nlu.tar.gz`（覆盖旧模型）
4. 重启 FastAPI 服务（或实现热加载）
5. 新模型生效

---

## 6. 核心代码实现

### 6.1 FastAPI 应用入口

**文件**：`app/main.py`

```python
from fastapi import FastAPI
from app.api.nlu_router import router as nlu_router

app = FastAPI(
    title="ERP Rasa NLU 意图识别服务",
    description="为ERP系统提供自然语言意图识别能力",
    version="1.0.0"
)

app.include_router(nlu_router)

@app.get("/")
async def root():
    return {"message": "ERP Rasa NLU Service is running!"}
```

**关键点**：
- 使用 FastAPI 创建应用实例
- 注册 NLU 路由（前缀：`/nlu`）
- 提供根路径健康检查

### 6.2 配置管理

**文件**：`app/core/config.py`

```python
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent.parent

class Settings:
    MODEL_PATH: str = str(BASE_DIR / "models" / "latest_nlu.tar.gz")
    API_PORT: int = 8000

settings = Settings()
```

**关键点**：
- 使用 `Path` 对象构建模型路径（跨平台兼容）
- 模型文件固定名称：`latest_nlu.tar.gz`
- 可通过环境变量覆盖配置（可选）

### 6.3 模型加载器

**文件**：`app/core/rasa_loader.py`

```python
from rasa.nlu.model import Interpreter
from app.core.config import settings
import os

class RasaNLULoader:
    _interpreter = None  # 类变量，单例模式

    @classmethod
    def get_interpreter(cls):
        if cls._interpreter is None:
            if not os.path.exists(settings.MODEL_PATH):
                raise FileNotFoundError(f"模型文件不存在: {settings.MODEL_PATH}")
            cls._interpreter = Interpreter.load(settings.MODEL_PATH)
        return cls._interpreter

# 导出便捷函数
interpreter = RasaNLULoader.get_interpreter
```

**关键点**：
- 单例模式：模型只加载一次，后续调用直接返回
- 模型加载是阻塞操作，首次调用会耗时（通常 1-3 秒）
- 如果模型文件不存在，抛出明确的错误信息

### 6.4 API 路由

**文件**：`app/api/nlu_router.py`

```python
from fastapi import APIRouter, HTTPException
from app.schemas.nlu_schema import TextInput, NLUResponse
from app.core.rasa_loader import RasaNLULoader

router = APIRouter(prefix="/nlu", tags=["NLU"])

@router.post("/predict", response_model=NLUResponse)
async def predict_intent(input: TextInput):
    # 1. 输入验证
    if not input.text.strip():
        raise HTTPException(status_code=400, detail="输入文本不能为空")
    
    # 2. 获取模型解释器
    interpreter = RasaNLULoader.get_interpreter()
    
    # 3. 调用模型进行推理
    # 注意：无论输入什么，Rasa 模型都会返回一个意图
    # - 如果能匹配到明确意图（置信度 ≥ 0.3），返回明确意图
    # - 如果无法匹配到明确意图（所有明确意图置信度 < 0.3），返回 nlu_fallback
    result = interpreter.parse(input.text)
    
    # 4. 格式化返回结果
    # result["intent"] 保证存在，要么是明确意图，要么是 nlu_fallback
    return NLUResponse(
        text=input.text,
        intent=result["intent"],  # 始终有值，不会为空
        entities=result.get("entities", []),
        intent_ranking=result.get("intent_ranking", [])[:5]
    )
```

**关键点**：
- 使用 `async def` 定义异步路由（FastAPI 支持）
- 输入验证：检查文本是否为空
- **核心保证**：`interpreter.parse()` 始终返回一个意图，不存在"无意图"的情况
- **意图分类**：
  - 明确意图：当最高置信度 ≥ 0.3 时，返回对应的明确意图（如 `query_order`、`check_inventory` 等）
  - 通用意图：当所有明确意图置信度 < 0.3 时，Rasa 的 `FallbackClassifier` 自动返回 `nlu_fallback`
- 结果格式化：限制 `intent_ranking` 为 Top 5

### 6.5 数据模型

**文件**：`app/schemas/nlu_schema.py`

```python
from pydantic import BaseModel
from typing import Dict, List, Optional

class TextInput(BaseModel):
    text: str

class IntentResult(BaseModel):
    name: str
    confidence: float

class EntityResult(BaseModel):
    entity: str
    value: str
    start: int
    end: int
    confidence: float

class NLUResponse(BaseModel):
    text: str
    intent: IntentResult
    entities: List[EntityResult] = []
    intent_ranking: List[Dict] = []
```

**关键点**：
- 使用 Pydantic 进行数据验证和序列化
- `entities` 和 `intent_ranking` 有默认值（空列表）
- `intent_ranking` 使用 `List[Dict]` 因为 Rasa 返回的格式可能不同

---

## 7. 部署与运行

### 7.1 环境准备

**前置要求**：
- Python ≥ 3.9
- uv（Python 包管理工具）

**安装 uv**（如果未安装）：
```bash
# macOS/Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# Windows (PowerShell)
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"

# 或使用 pip 安装
pip install uv
```

**项目初始化**：
```bash
# 克隆或创建项目目录
git clone <your-repo> erp-rasa-nlu-service
cd erp-rasa-nlu-service

# 使用 uv 创建虚拟环境并安装依赖
uv venv

# 激活虚拟环境
# Windows
.venv\Scripts\activate
# macOS/Linux
source .venv/bin/activate

# 安装项目依赖
uv pip install -e .
```

**项目结构**：
```
erp-rasa-nlu-service/
├── app/                          # FastAPI 核心代码
│   ├── __init__.py
│   ├── main.py                   # FastAPI 应用入口
│   ├── api/
│   │   └── nlu_router.py         # 意图识别 API 路由
│   ├── core/
│   │   ├── config.py             # 配置管理（模型路径等）
│   │   └── rasa_loader.py        # Rasa 模型单例加载
│   └── schemas/
│       └── nlu_schema.py         # 请求/响应数据模型
├── rasa_data/                    # Rasa NLU 训练数据
│   ├── nlu.yml                   # 意图定义 + 训练示例
│   └── config.yml                # NLU pipeline 配置
├── models/                       # 训练生成的模型文件
│   └── latest_nlu.tar.gz         # 固定名称的最新模型
├── scripts/                      # 实用脚本
│   └── train_rasa_nlu.py         # 一键训练 NLU 模型脚本
├── tests/                        # 单元测试（可选）
├── .env                          # 环境变量（可选）
├── pyproject.toml                # 项目配置和依赖声明（uv 使用）
├── .python-version               # Python 版本锁定（可选）
└── README.md                     # 项目说明
```

**pyproject.toml 配置示例**：
```toml
[project]
name = "erp-rasa-nlu-service"
version = "1.0.0"
description = "ERP 智能意图识别服务"
requires-python = ">=3.9"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "rasa>=3.6.0",
    "pydantic>=2.0.0",
    "python-dotenv>=1.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

**使用 uv 管理依赖的优势**：
- ⚡ **极速安装**：比 pip 快 10-100 倍
- 🔒 **依赖锁定**：自动生成 `uv.lock` 文件，确保依赖版本一致性
- 🎯 **精确解析**：更智能的依赖解析算法
- 📦 **统一管理**：虚拟环境和依赖管理一体化

**uv 常用命令**：
```bash
# 创建虚拟环境
uv venv

# 激活虚拟环境（Windows）
.venv\Scripts\activate
# 激活虚拟环境（macOS/Linux）
source .venv/bin/activate

# 安装依赖（从 pyproject.toml）
uv pip install -e .

# 安装单个包
uv pip install fastapi

# 运行 Python 脚本（自动使用虚拟环境）
uv run python scripts/train_rasa_nlu.py

# 运行命令（自动使用虚拟环境）
uv run uvicorn app.main:app --reload

# 同步依赖（根据 pyproject.toml 更新虚拟环境）
uv pip sync pyproject.toml

# 查看已安装的包
uv pip list

# 导出依赖到 requirements.txt（如果需要）
uv pip compile pyproject.toml -o requirements.txt
```

### 7.2 模型训练

**首次训练**（使用 uv 运行）：
```bash
# 方式1：激活虚拟环境后运行
uv run python scripts/train_rasa_nlu.py

# 方式2：直接使用 uv 运行（自动管理环境）
uv run python scripts/train_rasa_nlu.py
```

**训练完成后**，模型文件保存在 `models/latest_nlu.tar.gz`

### 7.3 启动服务

**开发环境**（使用 uv 运行）：
```bash
# 方式1：激活虚拟环境后运行
uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

# 方式2：直接使用 uv 运行（推荐）
uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

**生产环境**：
```bash
# 使用 uv 运行
uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4

# 或激活虚拟环境后运行
source .venv/bin/activate  # Windows: .venv\Scripts\activate
uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4
```

**uv 运行命令说明**：
- `uv run` 会自动使用项目的虚拟环境（`.venv`）
- 如果虚拟环境不存在，会自动创建
- 如果依赖未安装，会自动安装
- 无需手动激活虚拟环境

### 7.4 测试接口

**使用 curl**：
```bash
curl -X POST http://localhost:8000/nlu/predict \
  -H "Content-Type: application/json" \
  -d '{"text": "帮我查一下订单12345的状态"}'
```

**访问 API 文档**：
- Swagger UI：http://localhost:8000/docs
- ReDoc：http://localhost:8000/redoc

---

## 8. 技术要点总结

### 8.1 关键技术决策

1. **单例模式加载模型**：避免重复加载，提升性能
2. **异步路由**：FastAPI 支持异步，但模型推理是同步的（已优化）
3. **Pydantic 数据验证**：自动验证请求和响应数据
4. **固定模型文件名**：`latest_nlu.tar.gz`，便于版本管理
5. **uv 依赖管理**：使用 uv 进行快速、可靠的依赖管理和虚拟环境管理

### 8.2 性能优化点

1. **模型单例**：只加载一次，后续调用直接使用
2. **模型轻量化**：使用 DIETClassifier，模型体积小（30-100MB）
3. **快速推理**：模型推理通常在 50-150ms 内完成

### 8.3 扩展性考虑

1. **新增意图**：修改 `nlu.yml`，重新训练即可
2. **新增实体**：在训练数据中标注实体，模型自动学习
3. **多语言支持**：修改 `config.yml` 中的 `language` 配置

---

**文档结束**
